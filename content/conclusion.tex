\section{Ausblick}
In der entwickelten Control Plane wurden nicht alle der erarbeiteten \textit{klugen} Features, beispielsweise das Parsen des \ac{mqtt} \verb|CONNECT| Paketes, um eine \textit{Session Affinity} basierend der Clientkennung zu realisieren, implementiert.
Wenn Envoy zukünftig das gesamte \ac{mqtt} Protokoll parst, können neben der \textit{Session Affinity} noch weitere protokollspezifische load balancing Entscheidungen getroffen werden.
Denkbar ist ein paketspezifisches load balancing aller \verb|PUBLISH| Pakete unter Berücksichtigung der Topic Aliasse der Clients. Dabei würde Envoy eine dedizierte Verbindung mit allen Nodes des Clusters aufbauen und kann darüber eingehende \verb|PUBLISH| Nachrichten einzeln an die Nodes verteilen.
Mit der fünften Version des \ac{mqtt} Protokolls wurden \textit{user properties} eingefügt, die es Benutzern erlauben, beliebige Daten als \textit{key-value} Paare an \ac{mqtt} Pakete anzuhängen \cite{raschbichlerMQTTHowNewa}.
Dies ermöglicht Load Balancern ein- und ausgehende Nachrichten mit nützlichen Informationen anzureichern.
\\
Während der Bearbeitung der vorliegenden Arbeit wurde HiveMQ Swarm \cite{teamHiveMQSwarmFind} von HiveMQ veröffentlicht. Mit diesem Tool können Client Verhaltensmuster definiert werden, um eine HiveMQ Cluster Installation für einen gegebenen Use-Case zu testen.
Mit HiveMQ Swarm kann iterativ eine Control Plane erweitert und für den eigenen Use-Case optimiert, sowie getestet werden.
\\
Zudem hat HiveMQ hat im Jahr 2020 eine Masterthesis angefertigt, in der das transparente Umziehen eines Clients auf einen anderen Node des Clusters untersucht wurde. Im Zusammenspiel mit der entwickelten Control Plane können gezielt \ac{mqtt} Clients, die eine hohe Last auf einem Node verursachen, transparent mit einem besser geeigneten Node verbunden werden.
\newpage

\section{Fazit}
Das Ziel der vorliegenden Arbeit war die Analyse des \ac{mqtt} Protokolls mit Hinblick auf das \textit{kluge} Verteilen der Clients an HiveMQ Nodes und die Erstellung einer Envoy Control Plane, die einige der analysierten Features implementiert.
\\
Die Vorbereitung auf diese Analyse bedurfte eine umfangreiche Einarbeitung in das \ac{mqtt} Protokoll, um die Eigenheiten und verschiedenen Verhaltensmuster der Clients zu untersuchen.
Trotz der in den letzten Jahren stetig steigenden Verwendung des Protokolls, unteranderem bei gro{\ss}en Cloud Anbietern wie Amazon Web Services und Microsoft Azure, gibt es öffentlich wenige Informationen zu dem Betrieb von \ac{mqtt} Brokern.
Auch der Support des \ac{mqtt} Protokolls in Proxies wie Nginx, HAProxy oder Envoy ist noch nicht gegeben. Dort ist es bereits möglich Protokoll \textit{sniffing} für Redis, MongoDB oder Postgres zu betreiben, um eine ausführliche Analayse des Traffics durchzuführen.
Der Mangel an Ressourcen des Ökosystems \textit{load balancing \ac{mqtt}} könnte durch die Kommerzialisierung im Bereich \ac{iiot} zu begründen sein.
\\
Um \ac{iot}-Plattformen zu optimieren, müssen entkoppelte Load Balancer ein integraler Bestandteil des \ac{iot}-Ökosystems werden. Sie müssen das Protokoll verstehen, Informationen der Plattform aggregieren und reaktive load balancing Entscheidungen treffen können. Nur so kann in Zukunft der Traffic von Milliarden \ac{iot}-Geräten optimal verteilt werden.
Der Load Balancer muss zu einem \textit{Smart Device} im \textit{Internet of Things} werden.

\begin{comment}
Die in dieser Thesis erarbeiteten Features unterscheiden einen entkoppelten \acl{lb} von einem \textit{klugen} \acl{lb}, der ein integraler Bestandteil des Ökosystems ist. Er versteht das Protokoll, aggregiert Informationen der Nodes und kann somit reaktive load balancing Entscheidungen treffen.

Der Ansatz des weighted \ac{cpu} round-robin load balancing Algorithmus, um auf die unterschiedlichen Lastverhalten der Clients zu reagieren, hat für die durchgeführten Testszenarien nicht besser als der round-robin Algorithmus abgeschnitten. Aufgrund der dynamischen Ermittlung der Gewichtungen kann dieser Ansatz jedoch in Zukunft auf den jeweiligen Anwendungsfall individuell angepasst werden.
Durch die Einführung einer Control Plane ist der \acl{lb} nicht nur konfigurierbar sondern programmierbar.
Metriken, wie beispielsweise die Anzahl der \ac{cpu} Kerne, die Regenerationsrate der Client-Credits oder die verwendete Netzwerkbandbreite des Nodes, können durch eine Erweiterung der Control Plane Einfluss auf die Gewichtungen der Nodes nehmen.
Diese Eigenschaft macht den Einsatz von Envoy im Anwendungsfall \ac{mqtt} optimal, da jede \ac{iot}-Plattform durch das versatile \ac{mqtt} Protokoll ein individuelles Lastverhalten schafft.
\\
% ---------------
Aus diesen Untersuchungen sind beispielsweise die Testszenarien aus Kapitel \ref{ss:test} entstanden, die zeigen sollen, dass bestimmte Verhaltensmuster der Clients eine ungleiche Lastverteilung im Cluster erzeugen können. Bei der Implementierung dieser Szenarien ist aufgefallen, wie komplex und unterschiedlich die Verhaltensmuster sein können.
Unterschiedliche Client Verhaltensmuster führen jedoch nicht grundsätzlich direkt zu einem Problem bei der Lastverteilung. Es ist die Kombination von unterschiedlichen Clients mit der Eigenschaft, dass \ac{mqtt} ein zustandsbehaftetes und verbindungsorientiertes Protokoll ist.
Der \acl{lb} kann nicht, wie zum Beispiel bei \ac{http}, einzelne Anfragen eines Clients an verschiedene Nodes schicken. Sobald ein Client verbunden ist, muss der Zielnode alle Anfragen des Clients bearbeiten, bis dieser die Verbindung beendet.
In der Realität will man dieses Verhalten bei \ac{http} oftmals gezielt erzwingen, um beispielsweise schnellere Antwortzeiten durch Cache-Speicher zu erzielen. Bei \ac{http} kann der \acl{lb} jedoch Pakete transparent zum Client an einen anderen Node schicken, wenn zum Beispiel der bisherige Zielnode überlastet ist. Bei \ac{mqtt} hat der \acl{lb} gar keine Möglichkeit die Last eines Clients nach dem Verbindungsaufbau zu steuern.
Dies untermauert die Relevanz der load balancing Entscheidung bei \ac{mqtt}.
\end{comment}

\begin{comment}

ausblick:
- extension die clients abschie{\ss}en kann
  - member einer shared subscription können immer abeschossen werden
- session roaming
- stateless

vielleicht:
- konzeptuell multiplexing

- man kann auch probleme bei clients lösen -> aber nicht alles
- load balancer unterstützt die steuerbarkeit

\end{comment}
